////////////////////////////////////////////////////////////////////////////////
// test_quadrature.cc
////////////////////////////////////////////////////////////////////////////////
/*! @file
//		Tests the quadrature routines by integrating a basis for polynomials up
//		to a particular degree over the canonical K-simplex.
//
//		Tables for these tests were generated by
//		Derivations/QuadratureValidation.nb
*/
//  Author:  Julian Panetta (jpanetta), julian.panetta@gmail.com
//  Company:  New York University
//  Created:  12/14/2014 16:02:02
////////////////////////////////////////////////////////////////////////////////
#include <MeshFEM/GaussQuadrature.hh>
#include <catch2/catch.hpp>
#include <iostream>
#include <functional>
#include <vector>
#include <cmath>

using namespace std;

typedef double Real;

template<size_t K, size_t Deg, typename F>
void test(const vector<vector<F>> &funcs, const vector<vector<Real>> &ints) {
    for (size_t d = 0; d <= Deg; ++d) {
        for (size_t i = 0; i < funcs[d].size(); ++i) {
            Real val = Quadrature<K, Deg>::integrate(funcs[d][i], 1.0);
            Real relError = std::abs((val - ints.at(d).at(i)) / ints.at(d).at(i));
            if (relError > 1e-15) {
                cerr << "Error on " << K << "D deg " << d << " function " << i
                     << " (Deg " << Deg << " quadrature): " << relError << endl;
                cerr << "computed: " << val << ", true: " << ints.at(d).at(i) << endl;
            }
            REQUIRE(relError <= 1e-15);
        }
    }
}

////////////////////////////////////////////////////////////////////////////////


// The monomials tested below generally don't include all integration
// variables; silence the resuting warnings on GCC and Clang.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

TEST_CASE("quadrature routines", "[quadrature]" ) {

    // 1D functions up to degree 4
    vector<vector<function<Real(Real, Real)>>> functions1D =
            {{[](Real u, Real other) { return 1; }},
             {[](Real u, Real other) { return u; }},
             {[](Real u, Real other) { return u*u; }},
             {[](Real u, Real other) { return u*u*u; }},
             {[](Real u, Real other) { return u*u*u*u; }}};
    vector<vector<Real>> integrals1D =
             {{1},{1.0 / 2.0},{1.0 / 3.0},{1.0 / 4.0},{1.0 / 5.0}};

    // 2D functions up to degree 5
    vector<vector<function<Real(Real, Real, Real)>>> functions2D =
        {{[](Real u, Real v, Real other) { return 1; }},
         {[](Real u, Real v, Real other) { return v; },
          [](Real u, Real v, Real other) { return u; }},
         {[](Real u, Real v, Real other) { return v*v; },
          [](Real u, Real v, Real other) { return u*v; },
          [](Real u, Real v, Real other) { return u*u; }},
         {[](Real u, Real v, Real other) { return v*v*v; },
          [](Real u, Real v, Real other) { return u*(v*v); },
          [](Real u, Real v, Real other) { return v*(u*u); },
          [](Real u, Real v, Real other) { return u*u*u; }},
         {[](Real u, Real v, Real other) { return v*v*v*v; },
          [](Real u, Real v, Real other) { return u*(v*v*v); },
          [](Real u, Real v, Real other) { return u*u*(v*v); },
          [](Real u, Real v, Real other) { return v*(u*u*u); },
          [](Real u, Real v, Real other) { return u*u*u*u; }},
         {[](Real u, Real v, Real other) { return v*v*v*v*v; },
          [](Real u, Real v, Real other) { return u*(v*v*v*v); },
          [](Real u, Real v, Real other) { return u*u*(v*v*v); },
          [](Real u, Real v, Real other) { return u*u*u*(v*v); },
          [](Real u, Real v, Real other) { return v*(u*u*u*u); },
          [](Real u, Real v, Real other) { return u*u*u*u*u; }}};
    vector<vector<Real>> integrals2D =
        {{1},
         {1.0 / 3.0,1.0 / 3.0},
         {1.0 / 6.0,1.0 / 12.0,1.0 / 6.0},
         {1.0 / 10.0,1.0 / 30.0,1.0 / 30.0,1.0 / 10.0},
         {1.0 / 15.0,1.0 / 60.0,1.0 / 90.0,1.0 / 60.0,1.0 / 15.0},
         {1.0 / 21.0,1.0 / 105.0,1.0 / 210.0,1.0 / 210.0,1.0 / 105.0,1.0 / 21.0}};

    // 3D functions up to degree 4
    vector<vector<function<Real(Real, Real, Real, Real)>>> functions3D =
        {{[](Real u, Real v, Real w, Real other) { return 1; }},
         {[](Real u, Real v, Real w, Real other) { return w; },
          [](Real u, Real v, Real w, Real other) { return v; },
          [](Real u, Real v, Real w, Real other) { return u; }},
         {[](Real u, Real v, Real w, Real other) { return w*w; },
          [](Real u, Real v, Real w, Real other) { return v*w; },
          [](Real u, Real v, Real w, Real other) { return v*v; },
          [](Real u, Real v, Real w, Real other) { return u*w; },
          [](Real u, Real v, Real w, Real other) { return u*v; },
          [](Real u, Real v, Real w, Real other) { return u*u; }},
         {[](Real u, Real v, Real w, Real other) { return w*w*w; },
          [](Real u, Real v, Real w, Real other) { return v*(w*w); },
          [](Real u, Real v, Real w, Real other) { return w*(v*v); },
          [](Real u, Real v, Real w, Real other) { return v*v*v; },
          [](Real u, Real v, Real w, Real other) { return u*(w*w); },
          [](Real u, Real v, Real w, Real other) { return u*v*w; },
          [](Real u, Real v, Real w, Real other) { return u*(v*v); },
          [](Real u, Real v, Real w, Real other) { return w*(u*u); },
          [](Real u, Real v, Real w, Real other) { return v*(u*u); },
          [](Real u, Real v, Real w, Real other) { return u*u*u; }},
         {[](Real u, Real v, Real w, Real other) { return w*w*w*w; },
          [](Real u, Real v, Real w, Real other) { return v*(w*w*w); },
          [](Real u, Real v, Real w, Real other) { return v*v*(w*w); },
          [](Real u, Real v, Real w, Real other) { return w*(v*v*v); },
          [](Real u, Real v, Real w, Real other) { return v*v*v*v; },
          [](Real u, Real v, Real w, Real other) { return u*(w*w*w); },
          [](Real u, Real v, Real w, Real other) { return u*v*(w*w); },
          [](Real u, Real v, Real w, Real other) { return u*w*(v*v); },
          [](Real u, Real v, Real w, Real other) { return u*(v*v*v); },
          [](Real u, Real v, Real w, Real other) { return u*u*(w*w); },
          [](Real u, Real v, Real w, Real other) { return v*w*(u*u); },
          [](Real u, Real v, Real w, Real other) { return u*u*(v*v); },
          [](Real u, Real v, Real w, Real other) { return w*(u*u*u); },
          [](Real u, Real v, Real w, Real other) { return v*(u*u*u); },
          [](Real u, Real v, Real w, Real other) { return u*u*u*u; }}};
    vector<vector<Real>> integrals3D =
        {{1},
         {1.0 / 4.0,1.0 / 4.0,1.0 / 4.0},
         {1.0 / 10.0,1.0 / 20.0,1.0 / 10.0,1.0 / 20.0,1.0 / 20.0,1.0 / 10.0},
         {1.0 / 20.0,1.0 / 60.0,1.0 / 60.0,1.0 / 20.0,1.0 / 60.0,1.0 / 120.0,1.0 / 60.0,1.0 / 60.0,1.0 / 60.0,1.0 / 20.0},
         {1.0 / 35.0,1.0 / 140.0,1.0 / 210.0,1.0 / 140.0,1.0 / 35.0,1.0 / 140.0,1.0 / 420.0,1.0 / 420.0,1.0 / 140.0,1.0 / 210.0,1.0 / 420.0,1.0 / 210.0,1.0 / 140.0,1.0 / 140.0,1.0 / 35.0}};

    SECTION("Degree 0 tests") {
      test<1, 0>(functions1D, integrals1D);
      test<2, 0>(functions2D, integrals2D);
      test<3, 0>(functions3D, integrals3D);
    }

    SECTION("Degree 1 tests") {
      test<1, 1>(functions1D, integrals1D);
      test<2, 1>(functions2D, integrals2D);
      test<3, 1>(functions3D, integrals3D);
    }

    SECTION("Degree 2 tests") {
      test<1, 2>(functions1D, integrals1D);
      test<2, 2>(functions2D, integrals2D);
      test<3, 2>(functions3D, integrals3D);
    }

    SECTION("Degree 3 tests") {
      test<1, 3>(functions1D, integrals1D);
      test<2, 3>(functions2D, integrals2D);
      test<3, 3>(functions3D, integrals3D);
    }

    SECTION("Degree 4 tests") {
      test<1, 4>(functions1D, integrals1D);
      test<2, 4>(functions2D, integrals2D);
      test<3, 4>(functions3D, integrals3D);
    }

    SECTION("Degree 5 tests") {
      test<2, 5>(functions2D, integrals2D);
    }
}

#pragma GCC diagnostic pop
